
## 실제 데이터 

실제 데이터는 복잡함. 하나의 상품이 여러개의 이미지를 가지고 있을 수 있고, 태그도 여러개일 수 있음. 

Pydantic은 복잡한 구조를 레고 조립하든 간단하게 표현할 수 있게 도와줌. 

## 모델 안에 다른 모델 넣기(중첩 모델)

```
class Image(BaseModel):
    url: str = Field(..., example="http://example.com/image.jpg")
    name: str = Field(..., example="멋진 상품 이미지")
```

이 이미지 모델을 Fields에 만들어두었던 item에 넣을 수 있음. 

```
from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

# 1. 서브 모델(Sub-model) 정의
class Image(BaseModel):
    url: str = Field(..., example="http://example.com/image.jpg")
    name: str = Field(..., example="멋진 상품 이미지")


# 2. 메인 모델(Item)에 서브 모델과 리스트를 타입으로 사용
class Item(BaseModel):
    name: str = Field(..., example="게이밍 마우스")
    description: str | None = Field(default=None, example="이 마우스는 놀라운 성능을 자랑합니다.")
    price: float = Field(..., gt=0, example=59.99)
    tax: float | None = Field(default=None, ge=0, example=0.1)
    
    # list[str] 타입을 사용하여 문자열의 배열을 받음
    tags: list[str] = Field(default=[], example=["전자제품", "게이밍", "PC 주변기기"])
    
    # Image 모델을 타입으로 사용하여 JSON 객체를 받음
    image: Image | None = Field(default=None)


@app.post("/items/")
def create_item(item: Item):
    return item

```


- **`tags: list[str] = Field(...)`**: `tags` 속성의 타입은 문자열을 담는 리스트(`list`)라고 정의했습니다. 이제 FastAPI는 이 필드에 **JSON 배열**을 기대합니다.
- **`image: Image | None = Field(...)`**: `image` 속성의 타입은 우리가 위에서 정의한 `Image` 모델이라고 명시했습니다. 이제 FastAPI는 이 필드에 `Image` 모델의 구조를 따르는 **중첩된 JSON 객체**를 기대합니다.


이 `Item` 모델에 데이터를 보내려면, 클라이언트는 아래와 같은 구조의 JSON을 요청 본문(Request Body)에 담아 보내야 합니다.

```
{
  "name": "게이밍 마우스",
  "description": "이 마우스는 놀라운 성능을 자랑합니다.",
  "price": 59.99,
  "tax": 0.1,
  "tags": [
    "전자제품",
    "게이밍",
    "PC 주변기기"
  ],
  "image": {
    "url": "http://example.com/mouse.jpg",
    "name": "고성능 게이밍 마우스"
  }
}
```

FastAPI와 Pydantic은 이 복잡한 JSON을 받아서 `tags`는 파이썬 `list`로, `image`는 `Image` 객체로 자동 변환하고, 그 안의 모든 값들(`url`, `name` 등)에 대한 유효성 검사까지 알아서 수행합니다.

