
**`pydantic-settings`**는 그 방식의 **'업그레이드 버전'**이자, FastAPI 프로젝트에서 설정을 관리하는 **가장 현대적이고 강력한 방법**입니다.


| 구분 | 기본 방법 (`python-dotenv` + `os`) | 업그레이드 방법 (`pydantic-settings`) |
| :--- | :--- | :--- |
| **핵심 원리** | `.env` 파일을 읽어와서 `os.getenv()`로 하나씩 꺼내 씀 | `.env` 파일을 **자동으로 읽고** Pydantic 모델에 **알아서** 채워 넣음 |
| **타입 변환** | 모든 값을 **문자열(string)**로 읽어옴.<br>숫자나 `bool`은 **직접 변환**해야 함<br>(예: `int(os.getenv("PORT"))`) | 타입 힌트(`PORT: int`)에 따라 **자동으로** 올바른 타입으로 변환해 줌 |
| **유효성 검사** | 검사 기능 없음. 값이 없는지 직접 확인해야 함 | Pydantic의 `Field`를 사용해 **필수 값, 기본값, 유효성 규칙** 설정 가능 |
| **코드 형태** | 절차적 (`VAR = os.getenv(...)`의 반복) | 선언적 (하나의 `Settings` 클래스로 정의) |

## 설치 

```
poetry add pydantic-settings
```



```
# app/config.py

from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # .env 파일에 있는 변수명과 똑같이 속성명을 정해주면 됩니다.
    # 타입 힌트를 지정하면 알아서 해당 타입으로 변환해 줍니다.
    APP_NAME: str
    DEBUG_MODE: bool
    DATABASE_URL: str
    SECRET_KEY: str

    # 만약 .env 파일 경로를 직접 지정하고 싶다면 아래와 같이 설정
    class Config:
        env_file = ".env"

# 설정 클래스의 인스턴스를 생성합니다.
# 다른 파일에서는 이 settings 객체를 import 해서 사용합니다.
settings = Settings()
```


- **`from pydantic_settings import BaseSettings`**: `pydantic-settings`에서 `BaseSettings`를 가져옵니다.
    
- **`class Settings(BaseSettings):`**: `BaseSettings`를 상속받는 `Settings` 클래스를 만듭니다.
    
- **`APP_NAME: str`**: `.env` 파일에 있는 `APP_NAME` 변수를 찾아 `str` 타입으로 `Settings` 객체의 `APP_NAME` 속성에 자동으로 할당해 줍니다.
    
- **`DEBUG_MODE: bool`**: **가장 큰 장점입니다!** `.env` 파일에 `DEBUG_MODE=True` 라고 적힌 문자열 `"True"`를 **자동으로 불리언(boolean) 타입 `True`로 변환**해 줍니다. 더 이상 `os.getenv(...) == "True"` 같은 코드를 쓸 필요가 없습니다.
    
- **`settings = Settings()`**: `Settings` 클래스의 인스턴스를 만듭니다. 이 코드가 실행되는 순간, `pydantic-settings`가 알아서 `.env` 파일을 읽고, 환경 변수를 검증하고, 타입에 맞게 변환해서 `settings` 객체를 완성합니다


## `main.py`에서 사용하기

이제 `main.py`에서 새로 만든 `settings` 객체를 import 해서 사용해 봅시다.

Python

```
# app/main.py

from fastapi import FastAPI
from .config import settings # config.py에서 settings 객체를 직접 import

app = FastAPI()

@app.get("/info/")
def get_info():
    # 이제 settings 객체의 속성으로 깔끔하게 접근할 수 있습니다.
    return {
        "app_name": settings.APP_NAME,
        "debug_mode": settings.DEBUG_MODE,
        "secret_key_prefix": settings.SECRET_KEY[:5] + "..."
    }
```

### 결과

이전과 똑같이 동작하지만, 코드는 훨씬 더 깔끔하고 안전해졌습니다.

- 타입이 보장됩니다.
    
- VSCode 같은 에디터에서 `settings.` 을 입력하면 자동 완성이 지원됩니다.
    
- 필수 환경 변수가 없으면 시작 시 에러를 발생시켜 실수를 방지합니다.
    

## Pydantic 과 Pydantic-setting 

둘의 관계는 게임기의 **'본체'**와 **'확장팩'**으로 생각하면 아주 쉬워요.

- **Pydantic**: 데이터 유효성 검사를 위한 강력한 **'게임기 본체'**입니다. API의 요청 본문(Body)이나 응답 모델(Response Model)처럼 일반적인 데이터의 모양과 규칙을 정의하는 핵심 기능을 담당합니다.
    
- **pydantic-settings**: **'설정 관리'**라는 특정 목적을 위해 만들어진 **'공식 확장팩'**입니다. Pydantic의 모든 강력한 기능(타입 힌트, 유효성 검사)을 그대로 사용하지만, `.env` 파일이나 환경 변수를 읽어오는 특수한 임무를 추가로 수행하는 거죠.

## 왜 분리되어 있나요?

원래 Pydantic 구버전(V1)에서는 이 설정 관리 기능이 내장되어 있었어요. 하지만 새 버전(V2)으로 올라오면서 다음과 같은 이유로 별도의 라이브러리로 분리되었습니다.

1. **핵심 기능 집중**: Pydantic 본체는 '일반적인 데이터 검증'이라는 핵심 기능에만 집중하고,
    
2. **선택적 설치**: '환경 변수를 통한 설정 관리'라는 약간 특수한 기능은 필요한 사람만 선택해서 설치하도록 한 것이죠.
    

이렇게 핵심 라이브러리는 가볍게 유지하고, 추가 기능은 별도의 패키지로 제공하는 것은 소프트웨어 개발에서 매우 흔하고 좋은 방식입니다.

## .과 .config 차이 

**파일(모듈) 전체를 가져올 것인가, 아니면 그 파일 안에 있는 특정 변수(객체) 하나만 콕 집어서 가져올 것인가**의 차이입니다.

---

## 비유: 공구함 vs 특정 공구

`config.py` 파일을 하나의 **'공구함'**이라고 생각해 보세요. 그 안에는 `APP_NAME`, `DEBUG_MODE` 등 여러 '공구'들이 들어있었죠.

### 1. `from . import config` ("공구함 전체를 가져와")

- **의미**: "나와 같은 위치에 있는 `config`라는 이름의 **공구함(파일 전체)**을 통째로 가져와서 `config`라는 이름표를 붙여줘."
    
- **사용법**: 공구함(`config`)을 먼저 부르고, 그 안에 있는 공구(`.`)를 꺼내야 합니다.
    
    - `config.APP_NAME`
        
    - `config.DEBUG_MODE`
        
- **언제 썼나?**: `pydantic-settings`를 쓰기 전, `config.py`에 `APP_NAME`, `DEBUG_MODE` 등 여러 변수가 흩어져 있을 때 사용했습니다.
    

---

### 2. `from .config import settings` ("공구함에서 'settings' 망치 하나만 꺼내줘")

- **의미**: "`config`라는 공구함(**파일**)으로 가서, 그 안에 있는 **`settings`라는 이름의 공구(객체) 하나만** 꺼내서 나에게 바로 줘."
    
- **사용법**: 이제 `settings`라는 공구를 직접 손에 쥐고 있으므로, 바로 사용할 수 있습니다.
    
    - `settings.APP_NAME`
        
    - `settings.DEBUG_MODE`
        
- **언제 썼나?**: `pydantic-settings`를 사용하면서, `config.py` 안의 모든 설정 정보가 `settings = Settings()` 라는 **단 하나의 객체**로 통합되었습니다. 이제 우리는 그 공구함에서 다른 건 볼 필요 없이 `settings`라는 만능 공구 하나만 가져오면 되는 것이죠.


| Import 방식 | 의미 | 사용법 |
| :--- | :--- | :--- |
| **`from . import config`** | `config` **파일(모듈)** 전체를 가져옴 | `config.변수명` |
| **`from .config import settings`** | `config` 파일 **안의** `settings` **객체**만 가져옴 | `settings.변수명` |
