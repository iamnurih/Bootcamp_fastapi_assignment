


| 구분                | FastAPI/Pydantic 자동 처리                                                   | 개발자 직접 처리 (Business Logic)                                                          |
| :---------------- | :----------------------------------------------------------------------- | :---------------------------------------------------------------------------------- |
| **역할**            | **문지기**: 데이터 형식, 타입, 필수값 검사                                              | **실무자**: 데이터의 실제 의미, 규칙, 권한 검사                                                      |
| **예시**            | - `price`가 숫자가 아닌 문자열일 때<br>- 필수 `name` 필드가 누락되었을 때<br>- JSON 형식이 깨져있을 때 | - 존재하지 않는 상품 ID를 조회할 때<br>- 이미 가입된 이메일로 가입을 시도할 때<br>- 권한이 없는 데이터를 수정하려고 할 때        |
| **관련 HTTP 상태 코드** | `422 Unprocessable Entity`<br>`400 Bad Request`                          | `404 Not Found`<br>`409 Conflict`<br>`403 Forbidden`<br>`500 Internal Server Error` |

### 4xx: 클라이언트 오류 (Client Errors)

`4xx` 계열의 오류는 **실패의 원인이 클라이언트(요청을 보낸 쪽)에게 있다**는 의미를 담고 있습니다.

#### **400 Bad Request (잘못된 요청)**

- **의미**: 서버가 클라이언트의 요청 자체를 **문법적으로 이해할 수 없을 때** 발생합니다.
    
- **상황**: 가장 대표적인 예는 서버가 JSON 데이터를 예상하고 있는데, 클라이언트가 JSON 형식이 깨진 문자열(`{"name": "test"`)을 보내는 경우입니다. 서버는 이걸 해석조차 할 수 없어서 "요청이 잘못되었으니 확인하고 다시 보내세요."라고 응답합니다.
    
- **FastAPI에서**: 개발자가 직접 만들기보다는, FastAPI가 유효하지 않은 JSON을 받았을 때 **자동으로** 이 에러를 발생시켜 줍니다.

#### 422 Unprocessable Cotent/Entity 

- Pydantic 모델과 일치하지 않는 데이터가 들어왔을 때. (방금 경험하신 것)
- **경로/쿼리 매개변수 타입 오류 (`422`)**: `@app.get("/items/{item_id}")`에서 `item_id`에 `int`를 기대했는데 `abc` 같은 문자열이 들어왔을 때.

#### **403 Forbidden (접근 금지)**

- **의미**: 서버가 클라이언트가 누구인지 **알아볼 수는 있지만(인증 성공)**, 해당 리소스에 접근할 **권한이 없어서** 요청을 거부하는 것입니다.
    
- **상황**: 일반 사용자가 관리자 전용 페이지에 접근하려고 시도하는 경우입니다. 서버는 "당신이 `user123`이라는 건 알겠지만, 이 페이지는 관리자만 볼 수 있어서 보여줄 수 없습니다."라고 말하는 것과 같습니다. 즉, **'인증(Authentication)'은 되었지만 '인가(Authorization)'에 실패**한 경우입니다.
    
- **FastAPI에서**: 로그인한 사용자의 등급(role)을 확인하고, 조건에 맞지 않을 때 개발자가 **직접** 이 에러를 발생시켜야 합니다.

```
if current_user.role != "admin":
    raise HTTPException(status_code=403, detail="관리자만 접근 가능합니다.")
```


#### **404 Not Found (찾을 수 없음)**

- **의미**: 클라이언트가 요청한 **리소스를 서버에서 찾을 수 없을 때** 발생합니다. 가장 흔하게 볼 수 있는 에러 중 하나입니다.
    
- **상황**: `GET /users/999` 처럼 999번 사용자를 조회했는데, 데이터베이스에 999번 사용자가 존재하지 않는 경우입니다. 요청 자체는 완벽하게 정상이지만, 대상이 존재하지 않는 것이죠.
    
- **FastAPI에서**: 데이터베이스에서 특정 ID로 데이터를 조회한 후, 결과가 없을 때 개발자가 **직접** 이 에러를 발생시켜야 합니다.

 ```
 user = db.get_user_by_id(user_id)
 if not user:
    raise HTTPException(status_code=404, detail="해당 사용자를 찾을 수 없습니다.")
```

#### **409 Conflict (충돌)**

- **의미**: 클라이언트의 요청이 서버의 **현재 상태와 충돌**하여 처리할 수 없을 때 발생합니다.
    
- **상황**: 이미 존재하는 아이디나 이메일로 회원가입을 시도하는 경우가 가장 대표적입니다. 클라이언트가 보낸 회원가입 데이터 자체는 유효하지만(`422`가 아님), "이미 존재하는 이메일"이라는 서버의 현재 상태와 충돌하여 요청을 완료할 수 없는 것이죠.
    
- **FastAPI에서**: 새로운 데이터를 생성(`POST`)하기 전에, 해당 데이터가 이미 존재하는지 확인하고, 만약 존재한다면 개발자가 **직접** 이 에러를 발생시킵니다.

    ```
    existing_user = db.get_user_by_email(new_user.email)
    if existing_user:
        raise HTTPException(status_code=409, detail="이미 사용 중인 이메일입니다.")
    ```


## 5xx: 서버 오류 (Server Errors)

`5xx` 계열의 오류는 **실패의 원인이 서버(요청을 받은 쪽)에게 있다**는 의미입니다. 클라이언트의 요청에는 아무런 문제가 없었습니다.

#### **500 Internal Server Error (내부 서버 오류)**

- **의미**: 서버에서 요청을 처리하는 도중 **예상치 못한 문제**가 발생했을 때 사용하는 포괄적인 에러 코드입니다.
    
- **상황**: 코드에 버그가 있어서 갑자기 에러가 터지거나, 데이터베이스 서버가 갑자기 응답하지 않거나, 서버가 외부 API를 호출했는데 실패하는 등, 말 그대로 서버 내부의 문제입니다. 개발자가 미처 예상하지 못하고 처리하지 않은 모든 에러가 여기에 해당됩니다.
    
- **FastAPI에서**: 개발자가 `try...except` 등으로 예외 처리를 하지 않은 코드에서 버그가 발생하면, FastAPI가 **자동으로** 이 에러를 발생시킵니다. 좋은 서버는 `500` 에러를 사용자에게 보여주지 않도록, 발생 가능한 예외들을 최대한 미리 처리해야 합니다.


| 코드 | 이름 | 원인 | 핵심 의미 |
| :--- | :--- | :--- | :--- |
| **400** | Bad Request | 클라이언트 | 요청의 **문법**이 틀림 (예: 깨진 JSON) |
| **403** | Forbidden | 클라이언트 | **권한**이 없음 (넌 누구인지 알지만 안돼) |
| **404** | Not Found | 클라이언트 | 요청한 **리소스**가 없음 (예: 존재하지 않는 사용자) |
| **409** | Conflict | 클라이언트 | 서버의 현재 **상태**와 충돌 (예: 이메일 중복) |
| **422** | Unprocessable Entity | 클라이언트 | 요청의 **내용(의미)**이 틀림 (Pydantic 유효성 검사 실패) |
| **500** | Internal Server Error | 서버 | 서버 코드의 **예상치 못한 버그** 또는 문제 |


### HTTP 상태 코드 이해하고 활용하기

HTTP 상태 코드는 클라이언트의 요청이 성공적으로 처리되었는지, 아니면 어떤 문제가 발생했는지 서버가 클라이언트에게 알려주는 **세 자리 숫자로 된 '신호등'**과 같습니다. 이 신호등의 색깔(숫자)을 보고 클라이언트는 다음 행동을 결정할 수 있습니다.

#### 상태 코드의 종류 (맨 앞자리 기준)

- **`1xx` (Informational)**: 요청을 받았으며, 처리 중이라는 정보 전달. 거의 사용하지 않습니다.
    
- **`2xx` (Successful)**: 요청이 **성공적으로** 접수, 이해, 처리되었음. (초록불 🟢)
    
- **`3xx` (Redirection)**: 요청을 완료하기 위해 추가적인 조치가 필요함. (예: 다른 주소로 이동)
    
- **`4xx` (Client Error)**: **클라이언트(요청을 보낸 쪽)의 실수**로 요청을 처리할 수 없음. (노란불 🟡)
    
- **`5xx` (Server Error)**: **서버의 문제**로 요청을 처리할 수 없음. (빨간불 🔴)

### 1. 자주 사용하는 성공 코드 (`2xx`)

#### `200 OK`

- **의미**: "요청이 성공적으로 처리되었습니다." 라는 의미의 **가장 일반적인 성공 응답**입니다.
    
- **주요 사용처**:
    
    - `GET`: 데이터를 성공적으로 조회했을 때.
        
    - `PUT` 또는 `PATCH`: 기존 데이터를 성공적으로 수정했을 때.
        
- **FastAPI 기본값**: `@app.get` 이나 `@app.put` 등에서 따로 지정하지 않으면 기본적으로 `200`을 반환합니다.
    

#### `201 Created` (생성됨)

- **의미**: "요청이 성공하여 **새로운 리소스가 성공적으로 생성**되었습니다."
    
- **주요 사용처**:
    
    - `POST`: 회원가입, 게시글 작성 등 새로운 데이터를 생성하는 요청이 성공했을 때. `200`보다 더 명확한 의미를 전달합니다.
        
- **FastAPI에서**: 새로운 리소스를 만드는 엔드포인트에서는 `status_code`를 `201`로 지정해 주는 것이 좋은 관례입니다.
    

#### `204 No Content` (내용 없음)

- **의미**: "요청은 성공했지만, 응답으로 보낼 **본문(Body) 데이터가 없습니다.**"
    
- **주요 사용처**:
    
    - `DELETE`: 데이터를 성공적으로 삭제한 후, "삭제 잘 됐어"라는 신호만 보내고 딱히 돌려줄 데이터가 없을 때.
        
- **FastAPI에서**: `Response` 객체를 사용하여 상태 코드만 반환할 때 사용합니다.


| 상황 | HTTP 상태 코드 | 의미 | FastAPI 구현 방법 |
| :--- | :--- | :--- | :--- |
| **데이터 생성 성공** | `201 Created` | 새로운 리소스가 생성됨 | `@app.post(status_code=201)` |
| **데이터 조회/수정 성공** | `200 OK` | 요청이 성공적으로 처리됨 | 기본값이므로 별도 지정 불필요 |
| **데이터 삭제 성공** | `204 No Content` | 성공했지만 보낼 내용 없음 | `return Response(status_code=204)` |
| **조건부 실패 (에러)** | `4xx` 또는 `5xx` | 클라이언트/서버 오류 | `raise HTTPException(...)` |


실습 1 데코레이터에 `status_code` 지정하기 (성공 기본값)

```
# app/main.py

from fastapi import FastAPI, status

app = FastAPI()

items_db = {}

# POST 요청 성공 시 기본 상태 코드를 201 Created로 지정
@app.post("/items/", status_code=status.HTTP_201_CREATED)
def create_item(name: str):
    item_id = len(items_db) + 1
    items_db[item_id] = {"name": name}
    return {"id": item_id, "name": name}

# GET 요청은 기본값이 200 OK 이므로 따로 지정할 필요 없음
@app.get("/items/{item_id}")
def get_item(item_id: int):
    return items_db.get(item_id)
```

`status_code=status.HTTP_201_CREATED`: 숫자 `201`을 직접 쓰는 것보다 `fastapi.status`에 미리 정의된 상수를 사용하면 코드가 더 명확해지고 오타를 줄일 수 있습니다.


실습 2: `HTTPException`으로 에러 반환하기 (실패 시)

```
# app/main.py (이전 코드에 이어서)
from fastapi import HTTPException

# ... create_item 함수는 그대로 ...

@app.get("/items/{item_id}")
def get_item(item_id: int):
    item = items_db.get(item_id)
    # 아이템이 존재하지 않는 경우, 404 에러를 발생시킴
    if not item:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, 
            detail=f"Item with id {item_id} not found"
        )
    return item
```
- `raise HTTPException(...)`: 이 코드가 실행되면 함수의 나머지 부분은 실행되지 않고, 즉시 지정된 상태 코드와 `detail` 메시지를 담은 에러 응답이 클라이언트에게 전송됩니다.


실습 3: `Response` 객체로 직접 반환하기 (`204` 등)

```
# app/main.py (이전 코드에 이어서)
from fastapi import Response

# ... create_item, get_item 함수는 그대로 ...

@app.delete("/items/{item_id}")
def delete_item(item_id: int):
    if item_id in items_db:
        del items_db[item_id]
        # 성공적으로 삭제했지만 보낼 내용이 없으므로 204 No Content 반환
        return Response(status_code=status.HTTP_204_NO_CONTENT)
    
    # 삭제할 아이템이 없으면 404 에러
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Item with id {item_id} not found"
    )
```

`return Response(status_code=...)`: `fastapi.Response` 객체를 직접 생성하여 반환합니다. 이 객체의 `content`(본문)를 비워두면, `204 No Content` 응답을 보낼 수 있습니다.
