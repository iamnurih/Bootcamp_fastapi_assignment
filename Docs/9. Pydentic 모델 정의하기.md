
```
from fastapi import FastAPI
from pydantic import BaseModel # pydantic에서 BaseModel을 가져옴

# 1. 데이터 규칙을 정의하는 Pydantic 모델 클래스
class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

app = FastAPI()

# 2. 이 모델을 사용하는 API 엔드포인트
@app.post("/items/")
def create_item(item: Item):
    return item
```


- `class Item(BaseModel):` Pydantic 모델을 만들려면 반드시 BaseModel을 상속받아야 함. BaseModel 안에 모든 데이터 검증 및 처리 기능이 들어 있음.
- `name: str`:
	- 이 모델은 `name`이라는 속성을 가지며, 그 타입은 반드시 문자열(`str`)이어야 한다고 선언했습니다. 기본값이 없으므로 **필수 항목**입니다.

- `description: str | None = None`:
	- `description` 속성의 타입은 문자열(`str`)이거나(`|`) `None`일 수 있습니다.
	- `= None`으로 기본값을 지정했기 때문에, 이 항목은 **선택 항목(Optional)**이 됩니다. 클라이언트가 `description`을 보내지 않아도 괜찮습니다.
	- 
- `price: float`:
    - `price`는 부동소수점 숫자(`float`) 타입이며, **필수 항목**입니다.
        
- `tax: float | None = None`:
    - `tax`는 `float` 타입이며, **선택 항목**입니다.

- `@app.post("/items/")`:
    
	- HTTP `POST` 메소드는 주로 새로운 데이터를 **생성(Create)**할 때 사용됩니다.

- `def create_item(item: Item):`:

	- **가장 중요한 부분.** `create_item` 함수의 매개변수 `item`의 타입 힌트를 우리가 방금 만든 Pydantic 모델인 `Item`으로 지정했습니다.
    
	- FastAPI는 이걸 보고 다음과 같은 마법 같은 일들을 자동으로 수행합니다.
    
	    1. HTTP 요청의 **본문(Body)**을 읽습니다.
        
	    2. 본문의 내용이 JSON 형식이라고 가정하고 **해석(Parse)**합니다.
        
	    3. 해석된 데이터가 `Item` 모델에 정의된 규칙에 맞는지 **검증(Validate)**합니다.
        
	        - 필수 항목인 `name`과 `price`가 있는가?
            
	        - `name`은 문자열, `price`는 숫자가 맞는가?
            
	        - 만약 `description`이나 `tax`가 있다면, 타입이 올바른가?
            
	    4. **검증에 실패하면**, 어떤 부분이 왜 잘못되었는지 아주 상세한 에러 메시지를 클라이언트에게 **자동으로 보냅니다.**
        
	    5. **검증에 성공하면**, 전달받은 데이터로 `Item` 객체를 생성하여 `create_item` 함수의 `item` 매개변수로 전달해줍니다.

-  `return item`:
    
    - 함수 안에서는 `item.name`, `item.price` 와 같이 파이썬 객체의 속성에 접근하듯이 데이터를 편하게 사용할 수 있습니다. 여기서는 일단 받은 데이터를 그대로 다시 반환해 보겠습니다.