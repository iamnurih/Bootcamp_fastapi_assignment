


| 구분                | FastAPI/Pydantic 자동 처리                                                   | 개발자 직접 처리 (Business Logic)                                                          |
| :---------------- | :----------------------------------------------------------------------- | :---------------------------------------------------------------------------------- |
| **역할**            | **문지기**: 데이터 형식, 타입, 필수값 검사                                              | **실무자**: 데이터의 실제 의미, 규칙, 권한 검사                                                      |
| **예시**            | - `price`가 숫자가 아닌 문자열일 때<br>- 필수 `name` 필드가 누락되었을 때<br>- JSON 형식이 깨져있을 때 | - 존재하지 않는 상품 ID를 조회할 때<br>- 이미 가입된 이메일로 가입을 시도할 때<br>- 권한이 없는 데이터를 수정하려고 할 때        |
| **관련 HTTP 상태 코드** | `422 Unprocessable Entity`<br>`400 Bad Request`                          | `404 Not Found`<br>`409 Conflict`<br>`403 Forbidden`<br>`500 Internal Server Error` |

### 4xx: 클라이언트 오류 (Client Errors)

`4xx` 계열의 오류는 **실패의 원인이 클라이언트(요청을 보낸 쪽)에게 있다**는 의미를 담고 있습니다.

#### **400 Bad Request (잘못된 요청)**

- **의미**: 서버가 클라이언트의 요청 자체를 **문법적으로 이해할 수 없을 때** 발생합니다.
    
- **상황**: 가장 대표적인 예는 서버가 JSON 데이터를 예상하고 있는데, 클라이언트가 JSON 형식이 깨진 문자열(`{"name": "test"`)을 보내는 경우입니다. 서버는 이걸 해석조차 할 수 없어서 "요청이 잘못되었으니 확인하고 다시 보내세요."라고 응답합니다.
    
- **FastAPI에서**: 개발자가 직접 만들기보다는, FastAPI가 유효하지 않은 JSON을 받았을 때 **자동으로** 이 에러를 발생시켜 줍니다.

#### 422 Unprocessable Cotent/Entity 

- Pydantic 모델과 일치하지 않는 데이터가 들어왔을 때. (방금 경험하신 것)
- **경로/쿼리 매개변수 타입 오류 (`422`)**: `@app.get("/items/{item_id}")`에서 `item_id`에 `int`를 기대했는데 `abc` 같은 문자열이 들어왔을 때.

#### **403 Forbidden (접근 금지)**

- **의미**: 서버가 클라이언트가 누구인지 **알아볼 수는 있지만(인증 성공)**, 해당 리소스에 접근할 **권한이 없어서** 요청을 거부하는 것입니다.
    
- **상황**: 일반 사용자가 관리자 전용 페이지에 접근하려고 시도하는 경우입니다. 서버는 "당신이 `user123`이라는 건 알겠지만, 이 페이지는 관리자만 볼 수 있어서 보여줄 수 없습니다."라고 말하는 것과 같습니다. 즉, **'인증(Authentication)'은 되었지만 '인가(Authorization)'에 실패**한 경우입니다.
    
- **FastAPI에서**: 로그인한 사용자의 등급(role)을 확인하고, 조건에 맞지 않을 때 개발자가 **직접** 이 에러를 발생시켜야 합니다.

```
if current_user.role != "admin":
    raise HTTPException(status_code=403, detail="관리자만 접근 가능합니다.")
```


#### **404 Not Found (찾을 수 없음)**

- **의미**: 클라이언트가 요청한 **리소스를 서버에서 찾을 수 없을 때** 발생합니다. 가장 흔하게 볼 수 있는 에러 중 하나입니다.
    
- **상황**: `GET /users/999` 처럼 999번 사용자를 조회했는데, 데이터베이스에 999번 사용자가 존재하지 않는 경우입니다. 요청 자체는 완벽하게 정상이지만, 대상이 존재하지 않는 것이죠.
    
- **FastAPI에서**: 데이터베이스에서 특정 ID로 데이터를 조회한 후, 결과가 없을 때 개발자가 **직접** 이 에러를 발생시켜야 합니다.

 ```
 user = db.get_user_by_id(user_id)
 if not user:
    raise HTTPException(status_code=404, detail="해당 사용자를 찾을 수 없습니다.")
```

#### **409 Conflict (충돌)**

- **의미**: 클라이언트의 요청이 서버의 **현재 상태와 충돌**하여 처리할 수 없을 때 발생합니다.
    
- **상황**: 이미 존재하는 아이디나 이메일로 회원가입을 시도하는 경우가 가장 대표적입니다. 클라이언트가 보낸 회원가입 데이터 자체는 유효하지만(`422`가 아님), "이미 존재하는 이메일"이라는 서버의 현재 상태와 충돌하여 요청을 완료할 수 없는 것이죠.
    
- **FastAPI에서**: 새로운 데이터를 생성(`POST`)하기 전에, 해당 데이터가 이미 존재하는지 확인하고, 만약 존재한다면 개발자가 **직접** 이 에러를 발생시킵니다.

    ```
    existing_user = db.get_user_by_email(new_user.email)
    if existing_user:
        raise HTTPException(status_code=409, detail="이미 사용 중인 이메일입니다.")
    ```


## 5xx: 서버 오류 (Server Errors)

`5xx` 계열의 오류는 **실패의 원인이 서버(요청을 받은 쪽)에게 있다**는 의미입니다. 클라이언트의 요청에는 아무런 문제가 없었습니다.

#### **500 Internal Server Error (내부 서버 오류)**

- **의미**: 서버에서 요청을 처리하는 도중 **예상치 못한 문제**가 발생했을 때 사용하는 포괄적인 에러 코드입니다.
    
- **상황**: 코드에 버그가 있어서 갑자기 에러가 터지거나, 데이터베이스 서버가 갑자기 응답하지 않거나, 서버가 외부 API를 호출했는데 실패하는 등, 말 그대로 서버 내부의 문제입니다. 개발자가 미처 예상하지 못하고 처리하지 않은 모든 에러가 여기에 해당됩니다.
    
- **FastAPI에서**: 개발자가 `try...except` 등으로 예외 처리를 하지 않은 코드에서 버그가 발생하면, FastAPI가 **자동으로** 이 에러를 발생시킵니다. 좋은 서버는 `500` 에러를 사용자에게 보여주지 않도록, 발생 가능한 예외들을 최대한 미리 처리해야 합니다.


| 코드 | 이름 | 원인 | 핵심 의미 |
| :--- | :--- | :--- | :--- |
| **400** | Bad Request | 클라이언트 | 요청의 **문법**이 틀림 (예: 깨진 JSON) |
| **403** | Forbidden | 클라이언트 | **권한**이 없음 (넌 누구인지 알지만 안돼) |
| **404** | Not Found | 클라이언트 | 요청한 **리소스**가 없음 (예: 존재하지 않는 사용자) |
| **409** | Conflict | 클라이언트 | 서버의 현재 **상태**와 충돌 (예: 이메일 중복) |
| **422** | Unprocessable Entity | 클라이언트 | 요청의 **내용(의미)**이 틀림 (Pydantic 유효성 검사 실패) |
| **500** | Internal Server Error | 서버 | 서버 코드의 **예상치 못한 버그** 또는 문제 |
