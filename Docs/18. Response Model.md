

### 응답모델 

지금까지 우리 API는 함수가 반환하는 파이썬 딕셔너리나 Pydantic 객체를 그대로 JSON으로 변환해서 클라이언트에게 보냈습니다. 하지만 여기에는 잠재적인 위험이 있습니다.

만약 데이터베이스에서 사용자 정보를 가져왔는데, 실수로 `password`나 `secret_key` 같은 민감한 정보까지 함께 반환하면 어떻게 될까요? 이 정보가 그대로 클라이언트에게 노출되는 심각한 보안 사고가 발생할 수 있습니다.

**`response_model`**은 바로 이런 문제를 해결하기 위해 사용됩니다. 이것은 **"이 엔드포인트는 반드시 이 모양의 데이터만 응답할 거야"**라고 약속하고 강제하는 '응답 필터'입니다.

#### `response_model`의 역할과 장점

`response_model`은 경로 작동 함수 데코레이터(`@app.get(...)`) 안에서 사용하는 매개변수입니다.

1. **데이터 필터링 (보안)**: `response_model`로 지정된 Pydantic 모델에 포함되지 않은 필드는 **자동으로 제거**됩니다. 덕분에 민감한 데이터가 실수로 유출되는 것을 원천적으로 차단할 수 있습니다.
    
2. **데이터 유효성 검사**: 응답으로 나가는 데이터의 타입이 `response_model`과 일치하는지 검사하고, 필요하면 타입을 변환해 줍니다. (예: `int`를 `str`로)
    
3. **API 문서화**: API 문서(`docs`)에 이 엔드포인트가 어떤 구조의 JSON을 응답하는지 명확하게 명시해 줍니다. 프론트엔드 개발자는 이 문서만 보고도 어떤 데이터를 받게 될지 정확히 알 수 있습니다.


```
from fastapi import FastAPI
from pydantic import BaseModel, Field

app = FastAPI()

# 1. 입력 모델 (Request Body): 클라이언트가 보낼 데이터
class UserIn(BaseModel):
    username: str = Field(..., example="john_doe")
    email: str = Field(..., example="john.doe@example.com")
    password: str = Field(..., example="supersecretpassword")

# 2. 내부 데이터 모델 (DB 모델이라고 가정)
class UserInDB(UserIn):
    hashed_password: str = Field(..., example="$2b$12$EixZaY...")

# 3. 출력 모델 (Response Model): 클라이언트에게 보여줄 데이터
class UserOut(BaseModel):
    id: int = Field(..., example=1)
    username: str = Field(..., example="john_doe")
    email: str = Field(..., example="john.doe@example.com")


# 가짜 데이터베이스
fake_user_db = {}
user_counter = 0

# response_model로 UserOut을 지정!
@app.post("/users/", response_model=UserOut)
def create_user(user_in: UserIn):
    global user_counter
    user_counter += 1
    
    # 실제로는 password를 해싱해서 저장해야 합니다.
    hashed_password = "hashed_" + user_in.password
    
    # 1. 서버 내부에서는 hashed_password가 포함된 객체를 다룹니다.
    user_in_db = UserInDB(
        **user_in.model_dump(),
        hashed_password=hashed_password
    )
    
    # 2. 이 객체를 데이터베이스에 저장했다고 가정합니다.
    user_id = user_counter
    fake_user_db[user_id] = user_in_db.model_dump()
    
    # 3. 응답으로 보낼 데이터를 준비합니다. id 필드를 추가합니다.
    response_data = {"id": user_id, **user_in_db.model_dump()}
    
    # 4. password와 hashed_password가 모두 포함된 이 객체를 그대로 반환합니다!
    return response_data
```

- **3개의 모델**:
    
    - **`UserIn`**: 사용자를 생성할 때 클라이언트로부터 받을 데이터의 모양입니다.
        
    - **`UserInDB`**: 데이터베이스에 저장될 데이터의 모양입니다. 비밀번호가 해싱되어 저장됩니다.
        
    - **`UserOut`**: 클라이언트에게 응답으로 보낼 데이터의 모양입니다. **비밀번호 관련 필드가 아예 없습니다.**
        
- 데코레이터: `@app.post("/users/", response_model=UserOut)`**

	- `@app.post("/users/")`: "이 서버의 **/users/** 라는 주소로 **POST** 방식의 요청이 들어오면, 바로 아래에 있는 `create_user` 함수를 실행시켜라" 라는 **'경로 지정'** 약속입니다.
    
	- `response_model=UserOut`: "그리고 `create_user` 함수가 모든 계산을 끝내고 어떤 값을 반환하든, 클라이언트에게 최종적으로 응답을 보낼 때는 반드시 **`UserOut` 모델의 모양에 맞춰서 보내라**" 라는 **'응답 규칙'** 약속입니다. 즉, `UserOut`에 없는 필드는 응답에 포함시키지 말라는 '출구 필터' 역할을 합니다.
        
- 함수 정의: `def create_user(user_in: UserIn):`**

	- `def create_user(...)`: `create_user`라는 이름의 함수를 정의합니다.
    
	- `user_in: UserIn`: 이 부분이 **'입구 규칙'**입니다. FastAPI에게 "이 함수는 `UserIn` 모델 모양에 맞는 JSON 데이터를 요청 본문(Request Body)으로 받을 거야" 라고 알려줍니다. FastAPI는 요청이 오면 자동으로 JSON을 검증하고, `UserIn` 타입의 `user_in` 객체로 변환해서 함수 안으로 넣어줍니다.
    
    - 함수 안에서는 `user_in.username`, `user_in.password` 처럼 객체의 속성으로 데이터에 접근할 수 있습니다.
        

```
# 전역 변수 user_counter를 이 함수 안에서 수정하겠다고 선언
    global user_counter 
    # 새로운 사용자가 생성될 때마다 ID를 1씩 증가 (실제 DB의 auto-increment 흉내)
    user_counter += 1
```

위 코드는 진짜 데이터베이스가 없기 때문에, 새로운 사용자가 생길 때마다 고유한 ID를 부여하기 위한 간단한 시뮬레이션입니다.

```
# 클라이언트로부터 받은 평문 비밀번호(user_in.password)를 "해싱"했다고 가정
    hashed_password = "hashed_" + user_in.password
```

실제 서비스에서는 절대 비밀번호를 그대로 저장하지 않습니다. 암호화(해싱)해서 저장해야 하죠. 이 코드는 그 과정을 흉내 내는 것입니다. 이제 우리는 `hashed_password`라는, DB에 저장될 형태의 비밀번호를 갖게 되었습니다.

```
# UserInDB 모델 타입의 객체를 생성
    user_in_db = UserInDB(
        **user_in.model_dump(),
        hashed_password=hashed_password
    )
```

- **`user_in.model_dump()`**: 클라이언트에게 받은 `user_in` 객체를 다시 파이썬 딕셔너리로 변환합니다. 결과는 `{'username': '...', 'email': '...', 'password': '...'}` 와 같은 모습입니다.
    
- **`**` (더블 스타)**: 딕셔너리의 키와 값을 풀어헤쳐서 함수의 인자로 넣어주는 파이썬 문법입니다.
    
- 결과적으로 위 코드는 아래와 똑같습니다.

```
user_in_db = UserInDB(
    username=user_in.username,
    email=user_in.email,
    password=user_in.password,
    hashed_password=hashed_password
)
```

- 이제 `user_in_db` 객체는 DB에 저장될 완전한 형태의 데이터(`username`, `email`, `password`, `hashed_password`)를 모두 가지고 있습니다.

```
# 최종적으로 응답으로 반환할 데이터를 준비
    response_data = {"id": user_id, **user_in_db.model_dump()}
```

- `user_id`를 새로 생성하고, `user_in_db` 객체를 다시 딕셔너리로 변환하여 합칩니다.
    
- **이 시점에서 `response_data` 딕셔너리 안에는 `id`, `username`, `email`, `password`, `hashed_password`가 모두 들어있습니다!** 민감한 정보가 포함된 상태죠.


```
return response_data
```

- 함수는 민감한 정보가 포함된 `response_data`를 반환합니다.
    
- **바로 이때!** FastAPI가 개입합니다.
    
- FastAPI는 데코레이터에 있던 `response_model=UserOut` 약속을 기억하고 있습니다.
    
- `response_data`를 `UserOut` 모델과 비교합니다.
    
    - `UserOut`에는 `id`, `username`, `email` 필드만 있습니다.
        
- FastAPI는 `response_data`에서 `UserOut`에 있는 필드들만 골라내어 **새로운 응답 본문**을 만듭니다. `password`와 `hashed_password`는 `UserOut`에 없으므로 **이 단계에서 버려집니다.**
    
- 최종적으로 `id`, `username`, `email`만 포함된 안전한 JSON 데이터가 클라이언트에게 전송됩니다.

