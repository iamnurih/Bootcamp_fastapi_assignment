
### 📖 Case File: Docker 실행 불가 미스터리

**사건 개요**: FastAPI와 MySQL을 Docker를 사용해 연동하려 했으나, 알 수 없는 원인으로 `app` 컨테이너가 정상 실행되지 않는 문제 발생.

---

#### **Step 1: 최초의 단서 - `no configuration file`**

- **문제**: `docker-compose up` 실행 시, 설정 파일을 찾을 수 없다는 에러 발생.
    
- **원인**: `docker-compose.yml` 파일이 없는, 엉뚱한 폴더에서 명령어를 실행함.
    
- **해결**: `cd` 명령어로 프로젝트의 루트 폴더로 이동하여 문제를 해결.
    

---

#### **Step 2: 드러난 모순 - `additional properties 'app' not allowed`**

- **문제**: `docker-compose.yml` 파일의 문법이 틀렸다는 에러 발생.
    
- **원인**: `app` 서비스의 들여쓰기가 잘못되어, `db` 서비스의 하위 항목으로 인식됨.
    
- **해결**: `db`와 `app`이 동등한 레벨이 되도록 `docker-compose.yml`의 들여쓰기를 수정.
    

---

#### **Step 3: 사소한 경고와 또 다른 오류**

- **문제**: `version is obsolete` 경고와 `env file not found` 에러 동시 발생.
    
- **원인**: 최신 Docker Compose에서 `version` 태그는 불필요. `env_file` 경로 지정 방식이 모호함.
    
- **해결**: `version` 라인을 삭제하고, `env_file: .env`로 경로를 명확히 수정.
    

---

#### **Step 4: 꺼져있는 엔진 - `Cannot connect to the Docker daemon`**

- **문제**: Docker 명령어 자체가 동작하지 않음.
    
- **원인**: Docker의 엔진 역할을 하는 Docker Desktop 프로그램이 실행되고 있지 않음.
    
- **해결**: Docker Desktop을 실행하여 문제 해결.
    

---

#### **Step 5: 끈질긴 재시작 루프 - `exited with code 1`**

가장 길고 힘들었던 핵심 미스터리였습니다. `app` 컨테이너가 계속 재시작하는 현상의 원인을 찾기 위해 여러 가설을 세우고 검증했습니다.

- **가설 1: DB 연결 경쟁 상태?**
    
    - **내용**: `app`이 `db`보다 먼저 실행되어 연결에 실패하는 것으로 추측.
        
    - **시도**: `main.py`에 `lifespan` 이벤트를 도입하여 연결 시점을 늦춤.
        
    - **결과**: 실패. 문제는 더 근본적인 곳에 있었음.
        
- **가설 2: 라이브러리 미설치? (`ModuleNotFoundError: No module named 'tortoise'`)**
    
    - **내용**: 로그 확인 결과, `tortoise-orm` 라이브러리가 컨테이너에 설치되지 않은 것을 발견.
        
    - **시도**: `poetry add tortoise-orm asyncmy`로 `pyproject.toml`에 의존성을 추가하고, `poetry.lock` 파일을 재생성.
        
    - **결과**: `poetry` 버전 문제, Docker 캐시 문제 등이 겹치며 계속 실패.
        
- **가설 3: 시스템 의존성 부족? (`asyncmy` 빌드 실패)**
    
    - **내용**: 상세 로그 분석 결과, C언어 기반의 `asyncmy`를 컴파일할 도구가 Docker 이미지에 없다는 것을 발견.
        
    - **시도**: `Dockerfile`의 이미지를 `-slim`(다이어트 버전)에서 일반 버전(`python:3.13`)으로 변경하여 컴파일러를 포함시킴.
        
    - **결과**: 빌드는 성공했으나, 여전히 실행 실패.
        
- **가설 4: 경로 문제? (`no such file or directory`)**
    
    - **내용**: Multi-stage 빌드 시, 가상환경이 생성된 경로(`/app`)와 실행되는 경로(`/code`)가 달라 실행 파일을 못 찾는 것으로 추측.
        
    - **시도**: `Dockerfile`의 `WORKDIR`를 `/code`로 통일하여 경로 문제 해결.
        
    - **결과**: 빌드 및 실행 성공! **...인 줄 알았으나, 새로운 에러 발생.**
        

---

#### **Step 6: 마지막 범인들 - `ValidationError`**

- **문제**: 드디어 빌드는 성공했지만, 앱 실행 직후 Pydantic 설정 에러로 다시 종료됨.
    
- **원인 1**: `app/config.py` 파일에 `DEBUG_MODE`를 `DEBUG_MODEL`로 오타.
    
- **해결 1**: 오타 수정.
    
- **원인 2**: `.env` 파일의 `DATABASE_URL`이 `localhost`로 되어있어 `db` 컨테이너를 찾지 못함.
    
- **해결 2**: `localhost`를 Docker 서비스 이름인 `db`로 수정.
    

---

## 🏁 사건 종결

**최종 결론**: 문제는 하나의 거대한 원인이 아니라, **여러 개의 자잘한 실수들이 복합적으로 얽혀 발생한 연쇄 문제**였습니다. 우리는 탐정처럼 단서를 하나씩 찾아가며 모든 문제를 해결했고, 마침내 Docker 환경을 성공적으로 실행시켰습니다.


### 🕵️‍♂️ 트러블슈팅에 사용된 터미널 명령어 모음

#### 1. Docker Compose 기본 명령어

- **`docker-compose up --build`**
    
    - **의미**: `docker-compose.yml` 파일을 읽어, 이미지를 새로 빌드(`--build`)하고 컨테이너들을 실행(`up`)합니다. **가장 많이 사용한 핵심 명령어입니다.**
        
- **`docker-compose down`**
    
    - **의미**: `up`으로 실행된 모든 컨테이너와 네트워크를 깔끔하게 종료하고 제거합니다.
        
- **`docker-compose up`**
    
    - **의미**: 이미지를 새로 빌드하지 않고, 기존 이미지로 컨테이너를 실행합니다.
        

---

#### 2. 문제 진단 및 디버깅 명령어

- **`docker ps -a`**
    
    - **의미**: 현재 존재하는 모든 컨테이너(`-a`)의 목록과 상태(실행 중, 종료됨 등)를 보여줍니다. 컨테이너의 정확한 이름을 확인할 때 사용했습니다.
        
- **`docker logs [컨테이너_이름]`**
    
    - **의미**: 특정 컨테이너가 남긴 모든 로그를 출력합니다. **`exit code 1`의 진짜 원인을 찾는 데 결정적인 역할**을 했습니다.
        
- **`docker-compose exec app bash`**
    
    - **의미**: 실행 중인 `app` 컨테이너 안으로 들어가서 셸(`bash`)을 실행합니다. 컨테이너 내부 환경을 직접 조사할 때 사용했습니다.
        
- **`exit`**
    
    - **의미**: 컨테이너 안의 셸에서 빠져나와 원래 내 컴퓨터의 터미널로 돌아옵니다.
        

---

#### ### 3. Docker 빌드 고급 명령어

- **`docker-compose build --no-cache`**
    
    - **의미**: 중간 캐시를 전혀 사용하지 않고, 처음부터 깨끗하게 이미지를 빌드합니다. 캐시 문제 해결을 위해 사용했습니다.
        
- **`docker-compose up --build --force-recreate --no-cache`**
    
    - **의미**: 캐시 무시, 강제 재 생성 등 모든 옵션을 동원해 가장 강력하게 모든 것을 새로 시작하는 명령어입니다.
        

---

#### ### 4. Poetry 관련 명령어

- **`poetry add [라이브러리_이름]`**
    
    - **의미**: `pyproject.toml`에 새로운 라이브러리 의존성을 추가합니다. `tortoise-orm`을 추가할 때 사용했습니다.
        
- **`poetry lock`**
    
    - **의미**: `pyproject.toml`을 읽어 `poetry.lock` 파일을 생성하거나 업데이트합니다. 의존성 문제를 해결하기 위해 사용했습니다.
        
- **`poetry --version`**
    
    - **의미**: 현재 터미널에서 사용 중인 Poetry의 버전을 확인합니다.
        
- **`poetry self update`**
    
    - **의미**: Poetry 프로그램 자체를 최신 버전으로 업데이트합니다.
        

---

#### ### 5. 기본 탐색 명령어

- **`ls`** (macOS/Linux) 또는 **`dir`** (Windows)
    
    - **의미**: 현재 폴더의 파일 목록을 보여줍니다. `docker-compose.yml` 파일이 있는 올바른 위치인지 확인할 때 사용했습니다.
        
- **`cd [폴더_경로]`**
    
    - **의미**: 지정된 폴더로 이동합니다.