


**헤더**는 클라이언트와 서버가 서로에게 요청이나 응답에 대한 추가 정보를 전달하는 데 사용됩니다. 예를 들어, 클라이언트의 브라우저 종류(`User-Agent`), 데이터 압축 방식(`Accept-Encoding`), 또는 인증 토큰(`Authorization`) 같은 정보들이 헤더에 담겨 전송됩니다.

### 왜 굳이 헤더를 주고받을까?

결론부터 말하면, **'데이터의 내용물(Body)'**과 **'데이터를 다루는 방법(Header)'**을 분리하기 위해서입니다. 이 둘을 분리하면 웹이 훨씬 더 효율적이고 유연하게 동작할 수 있습니다.

가장 쉬운 비유는 **택배 상자**입니다.

- **본문 (Body)**: 상자 안에 들어있는 **실제 물건** (예: 내가 주문한 책, 옷, 전자제품)
    
- **헤더 (Header)**: 상자 겉면에 붙어있는 **송장 및 스티커** (예: 받는 사람 주소, 보내는 사람, "파손주의" 스티커, "당일배송" 스티커)
    

우리는 택배 기사님이 상자를 열어보지 않고도 송장만 보고 어디로, 어떻게 배송해야 할지 알기를 기대합니다. 웹도 마찬가지입니다. 중간의 수많은 네트워크 장비(라우터, 캐시 서버 등)나 서버가 요청의 내용물(Body)을 일일이 다 열어보지 않고도, 헤더만 보고 요청을 어떻게 처리해야 할지 빠르고 효율적으로 판단할 수 있어야 합니다.

대부분은 자동으로 생성되고, 일부는 개발자가 직접 추가합니다.

- **자동 생성**: **브라우저나 서버**가 자신의 상태를 알리기 위해 자동으로 만듭니다.

	- `User-Agent`: 크롬 브라우저가 "저는 크롬입니다"라고 자동으로 추가합니다.
    
	- `Host`: 브라우저가 "저는 [www.google.com](https://www.google.com)으로 가고 싶어요"라고 자동으로 추가합니다.
    
	- `Content-Length`: FastAPI 서버가 "제가 보내는 데이터의 크기는 150바이트입니다"라고 자동으로 계산해서 추가합니다.
	
- **개발자가 직접 추가**: **우리 서비스의 특정 로직**을 위해 개발자가 코드로 추가합니다.

	- `Authorization`: 프론트엔드 개발자가 로그인 성공 후 받은 토큰을 이 헤더에 담아 보내도록 코드를 작성합니다.
    
	- `X-API-Key`: 클라이언트 개발자가 우리 서버에 요청을 보낼 때, 미리 발급받은 API 키를 헤더에 담아 보내도록 코드를 작성합니다.
	- 
### 왜 다른 정보(Body)와 같이 받지 않는가?

이것이 바로 '분리'의 가장 큰 장점이 드러나는 부분입니다.

1. **효율성 (속도)**: 웹 서버 앞단에는 요청을 대신 받아주는 캐시(Cache) 서버나 보안을 담당하는 방화벽 등이 있습니다. 이 장비들은 요청의 **내용물(Body)까지 전부 읽으면 너무 느려집니다.** 대신 가벼운 **헤더**만 빠르게 읽어서 "이건 저장된 캐시를 줘도 되겠다", "이건 인증 토큰이 없으니 차단해야겠다" 등을 신속하게 판단할 수 있습니다.
    
2. **표준화 및 확장성**: `Content-Type` 헤더는 '내용물이 무엇인지' 알려주는 명찰과 같습니다. 이 명찰 덕분에 내용물(Body)은 **어떤 형식이든 될 수 있습니다.**
    
    - `Content-Type: application/json` → "내용물은 JSON입니다. 그렇게 해석하세요."
        
    - `Content-Type: image/png` → "내용물은 PNG 이미지 파일입니다. 그렇게 해석하세요."
        
    - `Content-Type: application/pdf` → "내용물은 PDF 문서입니다. 그렇게 해석하세요."
        
    
    만약 헤더와 본문이 분리되지 않았다면, 모든 데이터가 하나의 정해진 형식에 묶여 이미지나 파일 같은 다양한 데이터를 전송하기 매우 어려웠을 겁니다.
    
3. **목적의 명확성**: 헤더는 **메타데이터(데이터를 설명하는 데이터)**, 본문은 **실제 데이터**로 역할이 명확하게 나뉩니다. 코드를 읽고 관리하기가 훨씬 쉬워지고, 웹의 여러 구성 요소들이 각자의 역할에만 집중할 수 있게 됩니다.
    
결론적으로 헤더와 본문을 분리한 것은 웹을 만든 사람들의 매우 현명한 설계 결정이었고, 오늘날의 빠르고 다양한 웹 환경을 가능하게 한 기반 기술이라고 할 수 있습니다.

## 단일 헤더 예시

```
from fastapi import FastAPI, Header, Cookie
# Header와 Cookie를 fastapi에서 가져옵니다.

app = FastAPI()

@app.get("/headers/")
def read_headers(user_agent: str | None = Header(default=None)):
    return {"User-Agent": user_agent}
```


- `from fastapi import Header`: `fastapi`로부터 `Header`를 import 합니다.
    
- `user_agent: str | None = Header(default=None)`:
    
    - 함수의 매개변수 `user_agent`의 기본값으로 `Header()`를 사용했습니다.
        
    - FastAPI는 이것을 보고 "아, `user_agent`라는 이름의 헤더 값을 찾아서 이 매개변수에 넣어줘야겠다"라고 인식합니다.
        
    - `default=None`이므로, 해당 헤더가 없어도 에러 없이 `None` 값이 들어갑니다.

**중요한 자동 변환**: HTTP 헤더의 이름은 보통 `User-Agent`처럼 대시(`-`)를 사용하는 'kebab-case'입니다. 하지만 파이썬에서는 변수명에 대시를 사용할 수 없죠. FastAPI는 이 점을 고려하여, 파이썬 변수명의 언더스코어(`_`)를 자동으로 대시(`-`)로 변환해서 실제 헤더를 찾아줍니다. 즉, `user_agent`는 `User-Agent` 헤더에 매핑됩니다.


### 1. 표준 헤더 (Standard Headers)

웹이 원활하게 동작하기 위해 국제 표준(RFC)으로 약속된 헤더들입니다. 각각 정해진 이름과 목적이 있으며, 브라우저와 서버는 이 헤더들을 보고 서로의 상태나 요청/응답의 내용을 이해합니다.

가장 흔하게 사용되는 표준 헤더들을 목적별로 나눠보면 다음과 같습니다.

#### **요청(Request)에서 주로 사용되는 헤더**

클라이언트가 서버에게 보내는 정보입니다.

- **`Host`**: 내가 요청을 보내는 서버의 주소가 무엇인지 알려줍니다. (예: `www.google.com`)
    
- **`User-Agent`**: 요청을 보내는 클라이언트(브라우저, 앱 등)의 정보입니다. (예: `Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...`)
    
- **`Accept`**: 클라이언트가 이해할 수 있는 데이터 형식이 무엇인지 알려줍니다. "저는 JSON이나 XML로 된 데이터를 받을 수 있어요." 라는 뜻이죠. (예: `application/json`)
    
- **`Content-Type`**: 요청 본문(Body)에 담아 보내는 데이터의 형식이 무엇인지 알려줍니다. (예: `application/json`, `multipart/form-data`)
    
- **`Authorization`**: 사용자가 누구인지 증명하기 위한 인증 정보(주로 토큰)를 담습니다. "저는 로그인된 사용자입니다. 여기 제 신분증(토큰)이요." 라는 의미입니다. (예: `Bearer eyJhbGciOiJIUzI1Ni...`)
    

#### **응답(Response)에서 주로 사용되는 헤더**

서버가 클라이언트에게 보내는 정보입니다.

- **`Server`**: 응답을 보내는 웹 서버 소프트웨어의 정보입니다. (예: `nginx`)
    
- **`Content-Length`**: 응답 본문의 데이터 크기가 얼마인지 알려줍니다.
    
- **`Allow`**: 해당 URL에서 어떤 HTTP 메소드(`GET`, `POST` 등)를 사용할 수 있는지 알려줍니다.
    
- **`Set-Cookie`**: 브라우저에게 "이 쿠키를 저장해주세요." 라고 명령할 때 사용합니다.
    


이 외에도 캐싱(`Cache-Control`), 보안(`Content-Security-Policy`) 등 수많은 표준 헤더들이 있습니다. 

### 2. 사용자 지정 헤더 (Custom Headers)

표준 헤더만으로는 표현할 수 없는, 우리 서비스만의 특정 정보를 전달하고 싶을 때 직접 헤더를 만들어 사용할 수 있습니다.

예를 들면 다음과 같습니다.

- **`X-API-Key`**: 우리 서비스에서 발급한 고유 API 키를 전달받을 때
    
- **`X-Request-ID`**: 요청마다 고유한 ID를 부여해서 추적하고 디버깅할 때
    
- **`X-Client-Version`**: 앱의 버전을 전달받아 특정 버전의 사용자에게만 다른 응답을 주고 싶을 때
    

과거에는 사용자 지정 헤더 앞에 **`X-`** 를 붙이는 것이 일반적인 관례였습니다. "이것은 표준이 아닌 사용자 지정 헤더입니다"라는 표시였죠. 요즘은 필수는 아니지만, 여전히 많은 곳에서 혼동을 피하기 위해 `X-` 접두사를 사용하고 있습니다.

따라서 FastAPI에서 `user_agent = Header()` 처럼 표준 헤더를 읽을 수도 있고, `my_api_key: str = Header(alias="X-API-Key")` 처럼 직접 만든 헤더를 읽을수도 있습니다. 


### 일반적으로 몇 개, 그리고 어떤 헤더를 받을까?

일반적으로 API 엔드포인트 하나가 직접적으로 신경 쓰는 헤더는 **0개에서 3개 사이**입니다. 대부분의 헤더는 서버 앞단(Nginx, Cloudflare 등)이나 FastAPI 프레임워크 수준에서 알아서 처리하기 때문에, 우리 비즈니스 로직 코드에서는 **우리 서비스에 꼭 필요한 정보**만 명시적으로 받아서 사용합니다.

받아야 "좋은" 헤더는 정해져 있다기보다, **API의 기능에 따라 결정**됩니다. 가장 대표적인 경우는 다음과 같습니다.

1. **인증이 필요할 때 (가장 흔한 경우)**
    
    - **`Authorization`**: 사용자가 로그인된 상태인지, API를 호출할 권한이 있는지 확인할 때 **거의 항상** 사용합니다. 보통 "Bearer 토큰"이라는 암호화된 문자열이 담겨 옵니다. 이 헤더가 없거나 유효하지 않으면 "당신은 이 기능을 사용할 수 없습니다"라고 `401` 또는 `403` 에러를 응답해야 합니다.
        
2. **다국어 지원이 필요할 때**
    
    - **`Accept-Language`**: 클라이언트(브라우저, 앱)가 선호하는 언어가 무엇인지 알려줍니다. (예: `ko-KR`, `en-US`) 이 값을 받아서 한국 사용자에게는 한국어로, 미국 사용자에게는 영어로 된 에러 메시지나 데이터를 보내줄 수 있습니다.
        
3. **특수한 정보나 식별자가 필요할 때 (사용자 지정 헤더)**
    
    - **`X-Client-Version`**: 모바일 앱에서 API를 호출할 때, 앱의 버전(`1.2.0` 등)을 함께 보내도록 약속할 수 있습니다. 이걸로 특정 버전 이하의 구버전 앱 사용자에게는 "업데이트가 필요합니다" 같은 응답을 줄 수 있습니다.
        
    - **`X-Request-ID`**: 모든 요청에 고유한 ID를 부여해서, 나중에 에러가 발생했을 때 이 ID로 로그를 추적하기 쉽게 만들 때 사용합니다.

### 여러 헤더를 받는 실습 예제

이제 **인증 토큰(`Authorization`)**과 **선호 언어(`Accept-Language`)**, 그리고 **요청 ID(`X-Request-ID`)**를 함께 받는 API를 만들어 보겠습니다.

```
from fastapi import FastAPI, Header

app = FastAPI()

@app.get("/items/protected/")
def get_protected_items(
    # 1. 필수 헤더: 기본값이 없으므로 반드시 받아야 함
    authorization: str = Header(
        ...,
        description="Bearer 토큰을 포함한 인증 헤더"
    ),
    # 2. 선택적 헤더: FastAPI가 accept_language -> Accept-Language 로 자동 변환
    accept_language: str | None = Header(
        default="en-US",
        description="사용자가 선호하는 언어"
    ),
    # 3. 사용자 지정 헤더: alias를 사용하여 실제 헤더 이름 지정
    x_request_id: str | None = Header(
        default=None,
        alias="X-Request-ID",
        description="요청 추적을 위한 고유 ID"
    )
):
    # 실제로는 받은 authorization 토큰을 검증하는 로직이 필요합니다.
    # 여기서는 받은 값들을 그대로 출력해봅니다.
    return {
        "message": "보호된 아이템 목록입니다.",
        "auth_token_type": authorization.split(" ")[0] if " " in authorization else "Unknown",
        "preferred_language": accept_language,
        "request_id": x_request_id
    }
```


1. **`authorization: str = Header(...)`**
    
    - `...` (Ellipsis)를 사용해서 이 헤더가 **필수**임을 명시했습니다. 만약 클라이언트가 `Authorization` 헤더 없이 요청을 보내면, FastAPI는 자동으로 `422` 에러를 발생시킵니다.
        
2. **`accept_language: str | None = Header(...)`**
    
    - 파이썬 변수명은 `accept_language`지만, FastAPI는 언더스코어(`_`)를 대시(`-`)로 자동 변환하여 실제로는 `Accept-Language`라는 헤더를 찾습니다.
        
    - `default="en-US"`: 만약 헤더가 오지 않으면 기본값으로 "en-US"를 사용합니다.
        
3. **`x_request_id: str | None = Header(..., alias="X-Request-ID")`**
    
    - **`alias="X-Request-ID"`**가 핵심입니다. 우리 서비스에서 `X-Request-ID`라는 이름의 커스텀 헤더를 사용하기로 약속했지만, 이 이름은 파이썬 변수명으로 사용할 수 없습니다.
        
    - 이때 `alias`를 사용하면, Python 코드에서는 `x_request_id`라는 변수명을 사용하면서, FastAPI에게는 "실제 HTTP 헤더에서는 `X-Request-ID`라는 이름으로 찾아줘!"라고 알려줄 수 있습니다.
        

이제 `/docs`에서 이 엔드포인트를 테스트해보세요. `Authorization`, `accept-language`, `X-Request-ID` 세 개의 입력 필드가 나타날 것이고, `Authorization`은 필수 항목으로 표시될 겁니다.

한문단 정리: 

"헤더는 요청에 대한 메타데이터가 담기는 곳입니다. 이 중 상당수는 브라우저가 자동으로 만들어서 보내주며, FastAPI는 이것들을 쉽게 읽을 수 있게 도와줍니다. 우리는 로그인(`Authorization`)처럼 우리 서비스에 꼭 필요한 특정 헤더가 있는지, 그 값이 올바른지 직접 확인하고, 검증이 끝나면 사용자에게 맞는 데이터를 보내줍니다."